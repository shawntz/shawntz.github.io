---
// Hero section - Bold, editorial Framer-inspired design with orchestrated load animations
---

<section class="min-h-0 lg:min-h-screen relative">
  <!-- Hero Image Container -->
  <div class="max-w-[1800px] mx-auto px-8 sm:px-12 lg:px-20 xl:px-32 2xl:px-36 pt-24 pb-0">
    <div 
      class="hero-image relative w-full aspect-[16/9] lg:aspect-[21/9] rounded-3xl overflow-hidden group cursor-pointer"
      style="opacity: 0; transform: translateY(-30px);"
    >
      <!-- Placeholder gradient background - replace with your image -->
      <div class="absolute inset-0 bg-gradient-to-br from-evergreen-800 via-evergreen-900 to-evergreen-950">
        <!-- Abstract pattern overlay -->
        <div class="absolute inset-0 opacity-30">
          <div class="absolute top-1/4 left-1/4 w-96 h-96 bg-evergreen-400 rounded-full blur-3xl animate-float"></div>
          <div class="absolute bottom-1/4 right-1/3 w-80 h-80 bg-amber-500 rounded-full blur-3xl animate-float" style="animation-delay: 2s;"></div>
          <div class="absolute top-1/2 right-1/4 w-64 h-64 bg-sage-400 rounded-full blur-3xl animate-float" style="animation-delay: 4s;"></div>
        </div>
        
        <!-- Grid pattern -->
        <div class="absolute inset-0 opacity-10" style="background-image: linear-gradient(rgba(255,255,255,0.1) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.1) 1px, transparent 1px); background-size: 60px 60px;"></div>
      </div>
      
      <!-- Black and white image (default, bottom layer) -->
      <img 
        src="/shawn_phasic@3xbw.png" 
        alt="" 
        class="hero-image-bw absolute inset-0 w-full h-full object-cover transition-opacity duration-700 ease-out"
      />
      
      <!-- Color image (revealed on hover, top layer) -->
      <img 
        src="/shawn_phasic@3x.png" 
        alt="" 
        class="hero-image-color absolute inset-0 w-full h-full object-cover"
        id="hero-color-image"
      />
      
      <!-- Sine wave frequency visualizer overlay (revealed on hover) -->
      <canvas 
        id="frequency-canvas" 
        class="absolute inset-0 w-full h-full pointer-events-none opacity-0 transition-opacity duration-500"
        style="mix-blend-mode: screen;"
      ></canvas>
      
      <!-- Secret messages in corners (only visible when cursor is near) -->
      <div class="hero-secret-messages absolute inset-0 pointer-events-none">
        <!-- Top Left -->
        <div id="secret-top-left" class="hero-secret-message absolute top-4 left-4 text-xs font-mono text-white/60 mix-blend-difference opacity-0 transition-opacity duration-300">
          <span class="hero-secret-text">signals converge</span>
        </div>
        
        <!-- Top Right -->
        <div id="secret-top-right" class="hero-secret-message absolute top-4 right-4 text-xs font-mono text-white/60 mix-blend-difference text-right opacity-0 transition-opacity duration-300">
          <span class="hero-secret-text">patterns synchronize</span>
        </div>
        
        <!-- Bottom Left -->
        <div id="secret-bottom-left" class="hero-secret-message absolute bottom-4 left-4 text-xs font-mono text-white/60 mix-blend-difference opacity-0 transition-opacity duration-300">
          <span class="hero-secret-text">representations emerge</span>
        </div>
        
        <!-- Bottom Right -->
        <div id="secret-bottom-right" class="hero-secret-message absolute bottom-4 right-4 text-xs font-mono text-white/60 mix-blend-difference text-right opacity-0 transition-opacity duration-300">
          <span class="hero-secret-text">intelligence awakens</span>
        </div>
      </div>
      
      <!-- Subtle vignette -->
      <div class="absolute inset-0 bg-gradient-to-t from-black/20 via-transparent to-black/10 pointer-events-none"></div>
    </div>
  </div>
  
  <!-- Giant Name Typography -->
  <div class="hero-name-container max-w-[1800px] mx-auto px-8 sm:px-12 lg:px-20 xl:px-32 2xl:px-36 pt-0 pb-0 overflow-hidden">
    <div class="w-full overflow-hidden">
      <h1 
        class="hero-name font-bold tracking-tighter text-center whitespace-nowrap"
        style="color: var(--ink-primary); opacity: 0; transform: translateY(40px); font-family: 'Geist', 'Geist Placeholder', sans-serif;"
      >
        SHAWN SCHWARTZ
      </h1>
    </div>
  </div>
  
  <!-- Bottom Section -->
  <div 
    class="hero-content max-w-[1800px] mx-auto px-8 sm:px-12 lg:px-20 xl:px-32 2xl:px-36 py-8 pb-8 lg:pb-12"
    style="opacity: 0; transform: translateY(20px);"
  >
    <div class="flex flex-col lg:flex-row items-start justify-start lg:justify-end gap-6 lg:gap-16">
      <!-- Status Badge -->
      <div class="flex items-center gap-3 flex-shrink-0">
        <span class="relative flex h-3 w-3">
          <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-evergreen-400 opacity-75"></span>
          <span class="relative inline-flex rounded-full h-3 w-3 bg-evergreen-500"></span>
        </span>
        <span class="text-sm font-medium" style="color: var(--ink-secondary);">
          Available for Work
        </span>
      </div>
      
      <!-- Bio + Timezone grouped together -->
      <div class="flex flex-col gap-6 max-w-4xl lg:max-w-5xl">
        <div class="hero-description text-xl md:text-2xl lg:text-3xl font-display leading-snug" style="color: var(--ink-primary);">
          <div class="hero-line" data-line="0">ðŸ‘‹ Hey, thanks for stopping by. Let me introduce myself.</div>
          <div class="hero-line" data-line="1">I'm an experienced <span class="hero-keyword">software engineer</span> and <span class="hero-keyword">data scientist</span>.</div>
          <div class="hero-line" data-line="2">
            Ex-<span class="slack-gradient">Slack Research & Data Engineering</span>.
          </div>
          <div class="hero-line" data-line="3"><span class="hero-keyword">Research leader</span>, <span class="hero-keyword">builder</span>, and <span class="hero-keyword">maker</span>.</div>
          <div class="hero-line" data-line="4">Finishing a PhD in Computational Neuroscience at <span class="stanford-red">Stanford</span>.</div>
          <div class="hero-line" data-line="5"><span class="hero-keyword">Published expert</span> in the <span class="hero-keyword">psychology</span> and <span class="hero-keyword">neuroscience</span> of</div>
          <div class="hero-line" data-line="6">attention, learning, memory, and human performance.</div>
          <div class="hero-line" data-line="7">I design <span class="hero-keyword">human-centered tools</span>, <span class="hero-keyword">apps</span>, and <span class="hero-keyword">interfaces</span>.</div>
        </div>
        <!-- Location, Time, and Weather Info -->
        <div class="flex flex-row flex-wrap items-center justify-start gap-x-7 gap-y-2">
          <div class="hero-meta-item text-sm font-mono flex items-center gap-2" style="color: var(--ink-tertiary);">
            <span>//</span>
            <span class="flex items-center gap-2 flex-wrap">
              <span class="whitespace-nowrap">San Francisco, CA</span>
              <span class="hidden sm:inline">â€¢</span>
              <span id="local-time" class="whitespace-nowrap">--:--:--</span>
              <span class="hidden sm:inline">â€¢</span>
              <span id="weather-display" class="flex items-center gap-1.5 whitespace-nowrap">
                <span id="weather-icon" class="w-4 h-4 flex-shrink-0"></span>
                <span id="weather-temp">--Â°</span>
              </span>
            </span>
          </div>
          <a 
            href="#contact"
            class="hero-meta-item group inline-flex items-center gap-2 text-sm font-medium transition-colors hover:opacity-80"
            style="color: var(--ink-primary);"
          >
            Get in touch
            <svg class="w-4 h-4 transform group-hover:translate-x-0.5 group-hover:-translate-y-0.5 transition-transform" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
              <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 19.5l15-15m0 0H8.25m11.25 0v11.25"/>
            </svg>
          </a>
        </div>
      </div>
    </div>
  </div>
</section>

<style>
  /* Hero load animations */
  .hero-image {
    animation: heroImageIn 1s cubic-bezier(0.16, 1, 0.3, 1) 0.1s forwards;
  }
  
  /* Hero image hover effect - advanced blend reveal */
  .hero-image-bw {
    filter: grayscale(100%);
    transition: opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1);
  }
  
  .hero-image-color {
    opacity: 0;
    mix-blend-mode: normal;
    transition: opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    /* Dynamic gradient mask that follows cursor - will be set via JS */
    mask-image: linear-gradient(135deg, transparent 0%, transparent 50%, black 50%, black 100%);
    -webkit-mask-image: linear-gradient(135deg, transparent 0%, transparent 50%, black 50%, black 100%);
    mask-size: 200% 200%;
    -webkit-mask-size: 200% 200%;
    mask-repeat: no-repeat;
    -webkit-mask-repeat: no-repeat;
    mask-position: 0% 0%;
    -webkit-mask-position: 0% 0%;
  }
  
  .hero-image.group:hover .hero-image-bw {
    opacity: 1;
  }
  
  .hero-image.group:hover .hero-image-color {
    opacity: 1;
  }
  
  /* Secret messages styling */
  .hero-secret-messages {
    z-index: 10;
  }
  
  .hero-secret-message {
    transition: opacity 0.3s ease-in-out;
  }
  
  .hero-secret-text {
    display: inline-block;
    text-shadow: 0 0 10px rgba(255, 255, 255, 0.3),
                 0 0 20px rgba(255, 255, 255, 0.2);
    letter-spacing: 0.1em;
    transform: scale(0.95);
    transition: transform 0.3s ease;
  }
  
  .hero-secret-message.opacity-100 .hero-secret-text {
    transform: scale(1);
  }
  
  /* Smooth reveal on touch devices */
  @media (hover: none) {
    .hero-image-color {
      opacity: 0.6;
      mix-blend-mode: normal;
      mask-image: linear-gradient(135deg, transparent 0%, black 100%);
      -webkit-mask-image: linear-gradient(135deg, transparent 0%, black 100%);
    }
    
    .hero-secret-messages {
      opacity: 0.6;
    }
  }
  
  .hero-name {
    animation: heroNameIn 1s cubic-bezier(0.16, 1, 0.3, 1) 0.3s forwards;
    /* Ensure text stays within container bounds */
    display: block;
    box-sizing: border-box;
    /* Default size before JS kicks in */
    font-size: 122.876px;
    line-height: 148.9px;
    /* Smooth transitions for font-size and line-height changes */
    transition: font-size 0.6s cubic-bezier(0.4, 0, 0.2, 1), 
                line-height 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    /* Prevent text overflow */
    overflow: hidden;
    text-overflow: clip;
    max-width: 100%;
    width: 100%;
  }
  
  .hero-content {
    animation: heroContentIn 0.8s cubic-bezier(0.16, 1, 0.3, 1) 0.6s forwards;
    position: relative;
    z-index: 2;
    margin-bottom: 1rem;
  }
  
  /* Hero description line-by-line animation */
  .hero-description {
    display: block;
  }
  
  .hero-line {
    display: block;
    opacity: 0;
    transform: translateY(20px);
    margin-bottom: 0.15em;
    transition: opacity 0.6s cubic-bezier(0.16, 1, 0.3, 1),
                transform 0.6s cubic-bezier(0.16, 1, 0.3, 1);
  }
  
  .hero-line:last-child {
    margin-bottom: 0;
  }
  
  /* Trigger animation when line is visible */
  .hero-line.visible {
    opacity: 1;
    transform: translateY(0);
  }
  
  /* Meta items (location/time/weather/get in touch) animation */
  .hero-meta-item {
    opacity: 0;
    transform: translateY(15px);
  }
  
  .hero-meta-item.visible {
    animation: heroMetaItemIn 0.6s cubic-bezier(0.16, 1, 0.3, 1) forwards;
  }
  
  /* Stagger meta items - first one (location/time/weather), then second (get in touch) */
  .hero-meta-item:nth-of-type(1).visible {
    animation-delay: 0s;
  }
  
  .hero-meta-item:nth-of-type(2).visible {
    animation-delay: 0.15s;
  }
  
  @keyframes heroMetaItemIn {
    0% {
      opacity: 0;
      transform: translateY(15px);
    }
    100% {
      opacity: 1;
      transform: translateY(0);
    }
  }
  
  .hero-keyword {
    position: relative;
    font-weight: 600;
    color: var(--ink-primary);
    display: inline-block;
    padding: 0 0.15em;
    margin: 0 -0.15em;
    /* Animation will be triggered by scroll */
    animation: none;
    opacity: 0;
    transform: translateY(10px) scale(0.95);
  }

  /* Slack text in Slack aubergine (no pill or logo) */
  .slack-gradient {
    color: #4A154B; /* Slack aubergine */
    font-weight: 600;
    letter-spacing: 0.01em;
  }

  /* Stanford cardinal red text */
  .stanford-red {
    color: #8C1515;
    font-weight: 600;
  }
  
  /* Highlighter effect at an angle */
  .hero-keyword::before {
    content: '';
    position: absolute;
    top: 0.1em;
    left: -0.1em;
    right: -0.1em;
    bottom: 0.1em;
    background: linear-gradient(
      105deg,
      rgba(255, 255, 0, 0.35) 0%,
      rgba(255, 255, 0, 0.5) 20%,
      rgba(255, 240, 0, 0.6) 50%,
      rgba(255, 255, 0, 0.5) 80%,
      rgba(255, 255, 0, 0.35) 100%
    );
    transform: skewX(-12deg) scaleX(0);
    transform-origin: left center;
    z-index: -1;
    border-radius: 3px;
    animation: none;
    box-shadow: 0 1px 2px rgba(255, 255, 0, 0.2);
  }
  
  /* Trigger animations when scrolled */
  /* Trigger keyword animations when their parent line is visible */
  .hero-line.visible .hero-keyword {
    animation: keywordHighlight 0.8s cubic-bezier(0.16, 1, 0.3, 1) forwards;
  }
  
  .hero-line.visible .hero-keyword::before {
    animation: keywordHighlighter 0.6s cubic-bezier(0.16, 1, 0.3, 1) forwards;
  }
  
  /* Stagger keyword animations within each line */
  .hero-line.visible .hero-keyword:nth-of-type(1) {
    animation-delay: 0.2s;
  }
  
  .hero-line.visible .hero-keyword:nth-of-type(1)::before {
    animation-delay: 0.4s;
  }
  
  .hero-line.visible .hero-keyword:nth-of-type(2) {
    animation-delay: 0.35s;
  }
  
  .hero-line.visible .hero-keyword:nth-of-type(2)::before {
    animation-delay: 0.55s;
  }
  
  .hero-line.visible .hero-keyword:nth-of-type(3) {
    animation-delay: 0.5s;
  }
  
  .hero-line.visible .hero-keyword:nth-of-type(3)::before {
    animation-delay: 0.7s;
  }
  
  .hero-line.visible .hero-keyword:nth-of-type(4) {
    animation-delay: 0.65s;
  }
  
  .hero-line.visible .hero-keyword:nth-of-type(4)::before {
    animation-delay: 0.85s;
  }
  
  @keyframes heroLineIn {
    0% {
      opacity: 0;
      transform: translateY(20px);
    }
    100% {
      opacity: 1;
      transform: translateY(0);
    }
  }
  
  @keyframes keywordHighlight {
    0% {
      opacity: 0;
      transform: translateY(10px) scale(0.95);
    }
    100% {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
  }
  
  @keyframes keywordHighlighter {
    0% {
      transform: skewX(-12deg) scaleX(0);
    }
    100% {
      transform: skewX(-12deg) scaleX(1);
    }
  }
  
  /* On large screens, add even more bottom margin to ensure scroll indicator doesn't overlap */
  @media (min-width: 1024px) {
    .hero-content {
      margin-bottom: 4rem;
    }
  }
  
  .hero-scroll {
    animation: fadeIn 0.6s ease-out 1s forwards;
    z-index: 1;
  }
  
  /* Ensure scroll indicator doesn't overlap content on smaller screens */
  @media (max-width: 1023px) {
    .hero-scroll {
      display: none !important;
    }
  }
  
  /* Remove extra bottom padding on mobile since we removed min-h-screen */
  @media (max-width: 1023px) {
    section {
      padding-bottom: 0;
    }
  }
  
  @keyframes heroImageIn {
    0% {
      opacity: 0;
      transform: translateY(-30px);
    }
    100% {
      opacity: 1;
      transform: translateY(0);
    }
  }
  
  @keyframes heroNameIn {
    0% {
      opacity: 0;
      transform: translateY(40px);
    }
    100% {
      opacity: 1;
      transform: translateY(0);
    }
  }
  
  @keyframes heroContentIn {
    0% {
      opacity: 0;
      transform: translateY(20px);
    }
    100% {
      opacity: 1;
      transform: translateY(0);
    }
  }
  
  @keyframes fadeIn {
    0% {
      opacity: 0;
    }
    100% {
      opacity: 1;
    }
  }
</style>

<script>
  // Frequency wave visualizer
  function initFrequencyWaves() {
    const canvas = document.getElementById('frequency-canvas') as HTMLCanvasElement;
    const heroImageContainer = document.querySelector('.hero-image');
    
    if (!canvas || !heroImageContainer) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    
    let isHovering = false;
    let animationId: number | null = null;
    let time = 0;
    
    // Wave configuration - multiple frequencies like an audio spectrum
    const waves = [
      { frequency: 0.008, amplitude: 15, speed: 0.02, color: 'rgba(255, 200, 100, 0.6)', phase: 0, yOffset: 0.15 },
      { frequency: 0.012, amplitude: 20, speed: 0.025, color: 'rgba(255, 150, 80, 0.5)', phase: 1.2, yOffset: 0.25 },
      { frequency: 0.006, amplitude: 25, speed: 0.015, color: 'rgba(255, 180, 120, 0.5)', phase: 2.4, yOffset: 0.35 },
      { frequency: 0.015, amplitude: 12, speed: 0.035, color: 'rgba(255, 220, 150, 0.4)', phase: 0.8, yOffset: 0.45 },
      { frequency: 0.01, amplitude: 18, speed: 0.028, color: 'rgba(255, 160, 90, 0.5)', phase: 1.6, yOffset: 0.55 },
      { frequency: 0.007, amplitude: 22, speed: 0.018, color: 'rgba(255, 190, 110, 0.45)', phase: 3.0, yOffset: 0.65 },
      { frequency: 0.014, amplitude: 14, speed: 0.032, color: 'rgba(255, 210, 140, 0.4)', phase: 0.4, yOffset: 0.75 },
      { frequency: 0.009, amplitude: 16, speed: 0.022, color: 'rgba(255, 170, 100, 0.5)', phase: 2.0, yOffset: 0.85 },
    ];
    
    function resizeCanvas() {
      const rect = heroImageContainer!.getBoundingClientRect();
      canvas.width = rect.width * window.devicePixelRatio;
      canvas.height = rect.height * window.devicePixelRatio;
      ctx!.scale(window.devicePixelRatio, window.devicePixelRatio);
    }
    
    function drawWave(wave: typeof waves[0], width: number, height: number) {
      if (!ctx) return;
      
      const yBase = height * wave.yOffset;
      
      ctx.beginPath();
      ctx.strokeStyle = wave.color;
      ctx.lineWidth = 1.5;
      
      // Draw main sine wave
      for (let x = 0; x <= width; x += 2) {
        // Combine multiple sine waves for more organic movement
        const y = yBase + 
          Math.sin(x * wave.frequency + time * wave.speed + wave.phase) * wave.amplitude +
          Math.sin(x * wave.frequency * 0.5 + time * wave.speed * 1.3 + wave.phase * 0.7) * (wave.amplitude * 0.3);
        
        if (x === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      
      ctx.stroke();
      
      // Draw secondary thinner wave offset slightly
      ctx.beginPath();
      ctx.strokeStyle = wave.color.replace(/[\d.]+\)$/, '0.25)');
      ctx.lineWidth = 0.8;
      
      for (let x = 0; x <= width; x += 2) {
        const y = yBase + 
          Math.sin(x * wave.frequency * 1.2 + time * wave.speed * 0.8 + wave.phase + 0.5) * wave.amplitude * 0.6 +
          Math.sin(x * wave.frequency * 0.7 + time * wave.speed * 1.1 + wave.phase * 1.2) * (wave.amplitude * 0.2);
        
        if (x === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      
      ctx.stroke();
    }
    
    function animate() {
      if (!isHovering || !ctx) {
        animationId = null;
        return;
      }
      
      const rect = heroImageContainer!.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;
      
      // Clear canvas
      ctx.clearRect(0, 0, width, height);
      
      // Draw all waves
      waves.forEach(wave => drawWave(wave, width, height));
      
      time += 1;
      animationId = requestAnimationFrame(animate);
    }
    
    function startAnimation() {
      isHovering = true;
      canvas.style.opacity = '1';
      if (!animationId) {
        animate();
      }
    }
    
    function stopAnimation() {
      isHovering = false;
      canvas.style.opacity = '0';
    }
    
    // Initialize
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    heroImageContainer.addEventListener('mouseenter', startAnimation);
    heroImageContainer.addEventListener('mouseleave', stopAnimation);
    
    // Cleanup on page transitions
    document.addEventListener('astro:before-swap', () => {
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
      window.removeEventListener('resize', resizeCanvas);
    });
  }
  
  // Hero image color reveal effect with advanced blend and gradient wipe
  function initHeroImageHover() {
    const heroImageContainer = document.querySelector('.hero-image');
    const colorImage = document.getElementById('hero-color-image');
    
    if (!heroImageContainer || !colorImage) return;
    
    // Get secret message elements
    const secretTopLeft = document.getElementById('secret-top-left');
    const secretTopRight = document.getElementById('secret-top-right');
    const secretBottomLeft = document.getElementById('secret-bottom-left');
    const secretBottomRight = document.getElementById('secret-bottom-right');
    
    let isHovering = false;
    const proximityThreshold = 300; // Distance in pixels to show secret messages (doubled from 150px)
    
    // Calculate distance between two points
    function getDistance(x1, y1, x2, y2) {
      return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }
    
    // Update secret messages visibility based on cursor proximity to corners
    function updateSecretMessages(e) {
      if (!isHovering) {
        // Hide all messages when not hovering
        [secretTopLeft, secretTopRight, secretBottomLeft, secretBottomRight].forEach(msg => {
          if (msg) msg.classList.remove('opacity-100');
        });
        return;
      }
      
      const rect = heroImageContainer.getBoundingClientRect();
      const cursorX = e.clientX - rect.left;
      const cursorY = e.clientY - rect.top;
      
      // Corner positions (with padding)
      const padding = 16; // Match the top-4/left-4 padding
      const corners = [
        { element: secretTopLeft, x: padding, y: padding },
        { element: secretTopRight, x: rect.width - padding, y: padding },
        { element: secretBottomLeft, x: padding, y: rect.height - padding },
        { element: secretBottomRight, x: rect.width - padding, y: rect.height - padding }
      ];
      
      // Show/hide messages based on proximity
      corners.forEach(corner => {
        if (!corner.element) return;
        
        const distance = getDistance(cursorX, cursorY, corner.x, corner.y);
        if (distance < proximityThreshold) {
          corner.element.classList.add('opacity-100');
        } else {
          corner.element.classList.remove('opacity-100');
        }
      });
    }
    
    // Update mask position directly based on cursor - no lag
    function updateMaskPosition(e) {
      if (!isHovering) return;
      
      const rect = heroImageContainer.getBoundingClientRect();
      // Calculate exact pixel position relative to the container
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      // Create radial gradient that follows cursor exactly
      // The gradient creates a smooth blend transition centered on the cursor
      const gradientSize = 500; // Size of the reveal circle in pixels
      
      // Use radial gradient centered exactly on cursor position using pixel values
      // This ensures perfect alignment with the pointer
      colorImage.style.maskImage = `radial-gradient(circle ${gradientSize}px at ${x}px ${y}px, black 0%, black 30%, transparent 70%)`;
      colorImage.style.webkitMaskImage = `radial-gradient(circle ${gradientSize}px at ${x}px ${y}px, black 0%, black 30%, transparent 70%)`;
      
      // Also update secret messages
      updateSecretMessages(e);
    }
    
    // Show color image on hover with blend effect
    heroImageContainer.addEventListener('mouseenter', (e) => {
      isHovering = true;
      colorImage.style.opacity = '1';
      
      // Initialize position immediately
      updateMaskPosition(e);
    });
    
    // Track mouse movement for reveal effect - updates immediately
    heroImageContainer.addEventListener('mousemove', updateMaskPosition);
    
    // Hide color image when not hovering
    heroImageContainer.addEventListener('mouseleave', (e) => {
      isHovering = false;
      colorImage.style.opacity = '0';
      
      // Hide all secret messages
      updateSecretMessages(e);
      
      // Reset mask
      colorImage.style.maskImage = 'linear-gradient(135deg, transparent 0%, transparent 50%, black 50%, black 100%)';
      colorImage.style.webkitMaskImage = 'linear-gradient(135deg, transparent 0%, transparent 50%, black 50%, black 100%)';
    });
  }
  
  // Dynamically adjust hero name font size to fit container with smooth animation
  function adjustHeroNameSize(disableTransitions = false) {
    // Early return if document not ready
    if (typeof document === 'undefined') return;
    const heroName = document.querySelector('.hero-name');
    const container = document.querySelector('.hero-name-container');
    const innerContainer = container?.querySelector('.w-full');
    
    if (!heroName || !container || !innerContainer) return;
    
    // Base size for large screens (2xl breakpoint and above)
    const baseFontSize = 122.876;
    const baseLineHeight = 148.9;
    const lineHeightRatio = baseLineHeight / baseFontSize; // ~1.212
    
    // Get the actual available width from the inner container (accounts for padding)
    const innerContainerRect = innerContainer.getBoundingClientRect();
    const availableWidth = innerContainerRect.width;
    
    // Skip if container has no width (not yet rendered)
    if (availableWidth <= 0) return;
    
    // Store original transition state
    const originalTransition = heroName.style.transition;
    
    // Disable transitions if requested (for urgent resizes)
    if (disableTransitions) {
      heroName.style.transition = 'none';
    }
    
    // Create a temporary clone for measurement to avoid affecting the visible element
    const clone = heroName.cloneNode(true);
    clone.style.position = 'absolute';
    clone.style.visibility = 'hidden';
    clone.style.width = 'auto';
    clone.style.maxWidth = 'none';
    clone.style.display = 'inline-block';
    clone.style.fontSize = `${baseFontSize}px`;
    clone.style.lineHeight = `${baseLineHeight}px`;
    clone.style.whiteSpace = 'nowrap';
    
    // Append clone to body for measurement
    document.body.appendChild(clone);
    
    // Measure text width
    const textWidth = clone.offsetWidth;
    
    // Remove clone
    document.body.removeChild(clone);
    
    // Use a more conservative scale factor (92% to ensure text never overflows)
    // Add a small buffer to account for any rounding or measurement inaccuracies
    const buffer = 4;
    const scale = ((availableWidth - buffer) * 0.92) / textWidth;
    
    // Calculate new font size and line height maintaining the same ratio
    const newFontSize = Math.max(20, baseFontSize * scale); // Minimum 20px
    const newLineHeight = newFontSize * lineHeightRatio;
    
    // Apply new size
    heroName.style.fontSize = `${newFontSize}px`;
    heroName.style.lineHeight = `${newLineHeight}px`;
    
    // Restore transitions if they were disabled
    if (disableTransitions) {
      // Re-enable transitions after a brief delay
      requestAnimationFrame(() => {
        heroName.style.transition = originalTransition || '';
      });
    }
  }
  
  // Use requestAnimationFrame for smoother resize handling with throttling
  let rafId = null;
  let lastWidth = 0;
  
  function handleResize() {
    // Cancel any pending animation frame
    if (rafId) {
      cancelAnimationFrame(rafId);
    }
    
    // Throttle with RAF - only resize if container width actually changed
    rafId = requestAnimationFrame(() => {
      const innerContainer = document.querySelector('.hero-name-container')?.querySelector('.w-full');
      const heroName = document.querySelector('.hero-name');
      
      if (!innerContainer || !heroName) {
        rafId = null;
        return;
      }
      
      const currentWidth = innerContainer.getBoundingClientRect().width;
      
      // Only resize if width actually changed (prevents unnecessary recalculations)
      if (Math.abs(currentWidth - lastWidth) > 1) {
        lastWidth = currentWidth;
        
        // Check if text is overflowing - if so, resize without transitions
        const textWidth = heroName.scrollWidth;
        const containerWidth = innerContainer.getBoundingClientRect().width;
        const isOverflowing = textWidth > containerWidth && containerWidth > 0;
        
        adjustHeroNameSize(isOverflowing);
      }
      
      rafId = null;
    });
  }
  
  // Use ResizeObserver for more immediate container size changes
  let resizeObserver = null;
  let isInitialized = false;
  
  function initialize() {
    if (isInitialized) return;
    isInitialized = true;
    
    // Initial sizing - run immediately without transitions to prevent cutoff
    requestAnimationFrame(() => {
      adjustHeroNameSize(true); // Disable transitions on first resize
      // Store initial width
      const innerContainer = document.querySelector('.hero-name-container')?.querySelector('.w-full');
      if (innerContainer) {
        lastWidth = innerContainer.getBoundingClientRect().width;
      }
    });
    
    // Setup ResizeObserver for container changes
    const container = document.querySelector('.hero-name-container');
    if (container && window.ResizeObserver) {
      resizeObserver = new ResizeObserver(handleResize);
      resizeObserver.observe(container);
    }
    
    // Also listen to window resize as fallback
    window.addEventListener('resize', handleResize);
  }
  
  // Run on load and resize
  if (typeof window !== 'undefined') {
    // Initialize hero image hover effect
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        initHeroImageHover();
        initFrequencyWaves();
      });
    } else {
      initHeroImageHover();
      initFrequencyWaves();
    }
    
    // Also initialize after page transitions
    document.addEventListener('astro:page-load', () => {
      initHeroImageHover();
      initFrequencyWaves();
    });
    
    // Immediate sizing attempt - try right away, then again on DOMContentLoaded
    // This ensures sizing happens as early as possible
    if (document.readyState === 'loading') {
      // Try immediate sizing if elements exist
      requestAnimationFrame(() => {
        const heroName = document.querySelector('.hero-name');
        const container = document.querySelector('.hero-name-container');
        if (heroName && container) {
          adjustHeroNameSize(true); // Disable transitions
        }
      });
      
      document.addEventListener('DOMContentLoaded', initialize);
    } else {
      initialize();
    }
    
    window.addEventListener('load', () => {
      if (!isInitialized) initialize();
      // Re-run sizing after load to ensure accuracy (with transitions enabled)
      requestAnimationFrame(() => adjustHeroNameSize(false));
    });
    
    // Also run after view transitions
    document.addEventListener('astro:page-load', () => {
      if (!isInitialized) initialize();
      requestAnimationFrame(() => adjustHeroNameSize(false));
    });
    
    // Run after animations complete to ensure correct sizing
    setTimeout(() => {
      requestAnimationFrame(() => adjustHeroNameSize(false));
    }, 1500);
    
    // Check if scroll indicator overlaps with content and hide if needed
    function checkScrollIndicatorOverlap() {
      const scrollIndicator = document.querySelector('.hero-scroll');
      const heroContent = document.querySelector('.hero-content');
      
      if (!scrollIndicator || !heroContent) return;
      
      // Only check on large screens where scroll indicator is visible
      if (window.innerWidth < 1024) return;
      
      const scrollRect = scrollIndicator.getBoundingClientRect();
      const contentRect = heroContent.getBoundingClientRect();
      
      // Check if scroll indicator overlaps with content (with some buffer)
      const buffer = 20;
      const overlaps = scrollRect.top < (contentRect.bottom + buffer);
      
      if (overlaps) {
        scrollIndicator.style.display = 'none';
      } else {
        scrollIndicator.style.display = 'flex';
      }
    }
    
    // Check overlap on load and resize
    window.addEventListener('load', () => {
      setTimeout(checkScrollIndicatorOverlap, 1600);
    });
    
    window.addEventListener('resize', () => {
      setTimeout(checkScrollIndicatorOverlap, 100);
    });
    
    // Also check after animations
    setTimeout(checkScrollIndicatorOverlap, 1600);
    
    // Display local time (updates every second)
    function updateLocalTime() {
      const timeDisplay = document.getElementById('local-time');
      if (!timeDisplay) return;
      
      try {
        // Use America/Los_Angeles timezone for San Francisco
        const now = new Date();
        const formatter = new Intl.DateTimeFormat('en-US', {
          timeZone: 'America/Los_Angeles',
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit',
          hour12: false
        });
        
        timeDisplay.textContent = formatter.format(now);
      } catch (e) {
        timeDisplay.textContent = '--:--:--';
      }
    }
    
    // Update time immediately and then every second
    if (typeof window !== 'undefined') {
      updateLocalTime();
      setInterval(updateLocalTime, 1000);
      // Also update after page transitions
      document.addEventListener('astro:page-load', () => {
        updateLocalTime();
        setInterval(updateLocalTime, 1000);
      });
    }
    
    // Fetch and display weather for San Francisco
    async function updateWeather() {
      const weatherDisplay = document.getElementById('weather-display');
      const weatherIcon = document.getElementById('weather-icon');
      const weatherTemp = document.getElementById('weather-temp');
      
      if (!weatherDisplay || !weatherIcon || !weatherTemp) return;
      
      try {
        // Using Open-Meteo API (free, no API key required)
        // San Francisco coordinates: 37.7749, -122.4194
        const lat = 37.7749;
        const lon = -122.4194;
        const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,weather_code&temperature_unit=fahrenheit&timezone=America%2FLos_Angeles`;
        
        const response = await fetch(url);
        if (!response.ok) throw new Error('Weather API error');
        
        const data = await response.json();
        const temp = Math.round(data.current.temperature_2m);
        const weatherCode = data.current.weather_code;
        
        weatherTemp.textContent = `${temp}Â°`;
        weatherIcon.innerHTML = getWeatherIconFromCode(weatherCode);
      } catch (error) {
        console.error('Weather fetch error:', error);
        weatherTemp.textContent = '--Â°';
        weatherIcon.innerHTML = getWeatherIcon('default');
      }
    }
    
    // Map WMO weather codes to icon types
    function getWeatherIconFromCode(code) {
      // WMO Weather Code mapping
      // 0: Clear sky, 1-3: Mainly clear/partly cloudy, 45-48: Fog, 51-67: Drizzle/Rain, 71-77: Snow, 80-99: Rain/Thunderstorm
      if (code === 0) return getWeatherIcon('clear');
      if (code >= 1 && code <= 3) return getWeatherIcon('clouds');
      if (code >= 45 && code <= 48) return getWeatherIcon('fog');
      if (code >= 51 && code <= 67) return getWeatherIcon('rain');
      if (code >= 71 && code <= 77) return getWeatherIcon('snow');
      if (code >= 80 && code <= 99) return getWeatherIcon('thunderstorm');
      return getWeatherIcon('default');
    }
    
    // Get weather icon SVG based on condition
    function getWeatherIcon(condition) {
      const icons = {
        'clear': '<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2.25a.75.75 0 01.75.75v2.25a.75.75 0 01-1.5 0V3a.75.75 0 01.75-.75zM7.5 12a4.5 4.5 0 119 0 4.5 4.5 0 01-9 0zM18.894 6.166a.75.75 0 00-1.06-1.06l-1.591 1.59a.75.75 0 101.06 1.061l1.591-1.59zM21.75 12a.75.75 0 01-.75.75h-2.25a.75.75 0 010-1.5H21a.75.75 0 01.75.75zM17.834 18.894a.75.75 0 001.06-1.06l-1.59-1.591a.75.75 0 10-1.061 1.06l1.59 1.591zM12 18a.75.75 0 01.75.75V21a.75.75 0 01-1.5 0v-2.25A.75.75 0 0112 18zM7.758 17.303a.75.75 0 00-1.061-1.06l-1.591 1.59a.75.75 0 001.06 1.061l1.591-1.59zM6 12a.75.75 0 01-.75.75H3a.75.75 0 010-1.5h2.25A.75.75 0 016 12zM6.697 7.757a.75.75 0 001.06-1.06l-1.59-1.591a.75.75 0 00-1.061 1.06l1.59 1.591z"/></svg>',
        'clouds': '<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><path d="M2.25 15a4.5 4.5 0 004.5 4.5H18a3.75 3.75 0 001.332-7.257 3 3 0 00-3.758-3.848 5.25 5.25 0 00-10.233 2.33A4.502 4.502 0 002.25 15z"/></svg>',
        'rain': '<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><path d="M2.25 15a4.5 4.5 0 004.5 4.5H18a3.75 3.75 0 001.332-7.257 3 3 0 00-3.758-3.848 5.25 5.25 0 00-10.233 2.33A4.502 4.502 0 002.25 15z"/><path d="M9 18.75l-1.5-1.5m6 0l-1.5-1.5m-3 3l-1.5-1.5m6 0l-1.5-1.5"/></svg>',
        'drizzle': '<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><path d="M2.25 15a4.5 4.5 0 004.5 4.5H18a3.75 3.75 0 001.332-7.257 3 3 0 00-3.758-3.848 5.25 5.25 0 00-10.233 2.33A4.502 4.502 0 002.25 15z"/><path d="M9 18.75l-1.5-1.5m6 0l-1.5-1.5m-3 3l-1.5-1.5m6 0l-1.5-1.5"/></svg>',
        'thunderstorm': '<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><path d="M2.25 15a4.5 4.5 0 004.5 4.5H18a3.75 3.75 0 001.332-7.257 3 3 0 00-3.758-3.848 5.25 5.25 0 00-10.233 2.33A4.502 4.502 0 002.25 15z"/><path d="M11.25 18.75l-2.25 3h3l-1.5 3"/></svg>',
        'snow': '<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><path d="M2.25 15a4.5 4.5 0 004.5 4.5H18a3.75 3.75 0 001.332-7.257 3 3 0 00-3.758-3.848 5.25 5.25 0 00-10.233 2.33A4.502 4.502 0 002.25 15z"/><path d="M9 18.75l-1.5-1.5m6 0l-1.5-1.5m-3 3l-1.5-1.5m6 0l-1.5-1.5"/><circle cx="9" cy="20.25" r="0.75"/><circle cx="15" cy="20.25" r="0.75"/></svg>',
        'mist': '<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><path d="M2.25 15a4.5 4.5 0 004.5 4.5H18a3.75 3.75 0 001.332-7.257 3 3 0 00-3.758-3.848 5.25 5.25 0 00-10.233 2.33A4.502 4.502 0 002.25 15z"/><path d="M3 18h18M6 15h12M9 21h6"/></svg>',
        'fog': '<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><path d="M2.25 15a4.5 4.5 0 004.5 4.5H18a3.75 3.75 0 001.332-7.257 3 3 0 00-3.758-3.848 5.25 5.25 0 00-10.233 2.33A4.502 4.502 0 002.25 15z"/><path d="M3 18h18M6 15h12M9 21h6"/></svg>',
        'default': '<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><path d="M2.25 15a4.5 4.5 0 004.5 4.5H18a3.75 3.75 0 001.332-7.257 3 3 0 00-3.758-3.848 5.25 5.25 0 00-10.233 2.33A4.502 4.502 0 002.25 15z"/></svg>'
      };
      
      return icons[condition] || icons['default'];
    }
    
    // Update weather on load and periodically (non-blocking)
    let weatherInterval;

    function initWeather() {
      // Clear any existing interval
      if (weatherInterval) {
        clearInterval(weatherInterval);
      }

      // Start weather update (non-blocking)
      setTimeout(() => updateWeather(), 0);

      // Update weather every 10 minutes
      weatherInterval = setInterval(updateWeather, 600000);
    }

    // Initialize weather
    initWeather();

    // Reinitialize after page transitions
    document.addEventListener('astro:page-load', () => {
      initWeather();
    });
    
    // Trigger hero description lines one by one as user scrolls
    function initHeroDescriptionScroll() {
      const heroLines = document.querySelectorAll('.hero-line');
      const heroMetaItems = document.querySelectorAll('.hero-meta-item');
      
      if (!heroLines.length && !heroMetaItems.length) return;
      
      // Create IntersectionObserver to watch each line individually
      const observerOptions = {
        root: null, // viewport
        rootMargin: '0px 0px -20% 0px', // Trigger when line is 20% from bottom of viewport
        threshold: 0.1 // Trigger when 10% of line is visible
      };
      
      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            // Add visible class to trigger animation
            entry.target.classList.add('visible');
            // Stop observing this line once it's visible
            observer.unobserve(entry.target);
          }
        });
      }, observerOptions);
      
      // Observe each line
      heroLines.forEach((line) => {
        observer.observe(line);
      });
      
      // Observe meta items (location/time/weather/get in touch)
      heroMetaItems.forEach((item) => {
        observer.observe(item);
      });
      
      // Also handle page transitions
      document.addEventListener('astro:page-load', () => {
        // Reset all lines
        heroLines.forEach((line) => {
          line.classList.remove('visible');
          observer.observe(line);
        });
        // Reset meta items
        heroMetaItems.forEach((item) => {
          item.classList.remove('visible');
          observer.observe(item);
        });
      });
    }
    
    // Initialize scroll detection
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initHeroDescriptionScroll);
    } else {
      initHeroDescriptionScroll();
    }
    
    // Also initialize after page transitions
    document.addEventListener('astro:page-load', initHeroDescriptionScroll);
  }
</script>
