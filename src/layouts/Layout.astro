---
import '../styles/index.css';
import Navigation from '../components/Navigation.astro';
import Footer from '../components/Footer.astro';
import CommandPalette from '../components/CommandPalette.astro';
import SelineAnalytics from '../components/SelineAnalytics.astro';
import { ClientRouter } from 'astro:transitions';
// import asciiArt from '../ascii/ascii-art.txt?raw';
import asciiArtSmall from '../ascii/ascii-art-small.txt?raw';
import asciiName from '../ascii/ascii-name.txt?raw';

interface Props {
  title: string;
  description?: string;
  image?: string;
}

const { 
  title, 
  description = "Software Engineer, Data Scientist, and ML Researcher finishing PhD at Stanford. Building intelligent systems that solve real problems at scale.",
  image = "/og-image.png"
} = Astro.props;

const canonicalURL = new URL(Astro.url.pathname, Astro.site);

// Strip comment markers from ascii-name (remove // at start of lines)
const asciiNameClean = asciiName.replace(/^\/\/\s*/gm, '');

// Escape the ASCII art for embedding in JavaScript
// Need to escape backslashes, backticks, and dollar signs for template literals
const asciiArtEscaped = asciiArtSmall
  .replace(/\\/g, '\\\\')  // Escape backslashes
  .replace(/`/g, '\\`')     // Escape backticks
  .replace(/\$/g, '\\$');  // Escape dollar signs

// Escape the name ASCII art
const asciiNameEscaped = asciiNameClean
  .replace(/\\/g, '\\\\')  // Escape backslashes
  .replace(/`/g, '\\`')     // Escape backticks
  .replace(/\$/g, '\\$');  // Escape dollar signs

// Create the script content as a string
const consoleScriptContent = `console.log(\`${asciiArtEscaped}\`);
console.log(\`${asciiNameEscaped}\`);`;
---

<!doctype html>
<html lang="en" class="no-transitions">
  <head>
    <!-- ASCII Art in page source -->
    <!-- 
{asciiArt}
{asciiNameClean}
    -->
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="generator" content={Astro.generator} />
    
    <!-- SEO -->
    <title>{title} | Shawn Schwartz</title>
    <meta name="description" content={description} />
    <link rel="canonical" href={canonicalURL} />
    
    <!-- Open Graph -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content={canonicalURL} />
    <meta property="og:title" content={title} />
    <meta property="og:description" content={description} />
    <meta property="og:image" content={new URL(image, Astro.site)} />
    
    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content={title} />
    <meta name="twitter:description" content={description} />
    <meta name="twitter:image" content={new URL(image, Astro.site)} />
    
    <!-- Fonts preload -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    
    <!-- Astro View Transitions - Framer-like smooth page transitions -->
    <ClientRouter />
    
    <!-- ASCII Art Console Log -->
    <script is:inline set:html={consoleScriptContent}></script>
    
    <!-- Theme initialization - runs before page renders to prevent flash -->
    <script is:inline>
      (function() {
        const theme = localStorage.getItem('theme') || 'system';
        const systemDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const shouldBeDark = theme === 'dark' || (theme === 'system' && systemDark);
        
        if (shouldBeDark) {
          document.documentElement.classList.add('dark');
        }
        
        // Remove no-transitions class after page load
        window.addEventListener('load', () => {
          requestAnimationFrame(() => {
            document.documentElement.classList.remove('no-transitions');
          });
        });
      })();
    </script>

    <!-- Navigation Direction Detection for View Transitions -->
    <script is:inline>
      (function() {
        // Track navigation direction for directional transitions
        // let navigatingForward = true; // Removed - currently unused
        let navigationStack = [];

        // Initialize with current path
        if (!sessionStorage.getItem('navigationStack')) {
          navigationStack = [window.location.pathname];
          sessionStorage.setItem('navigationStack', JSON.stringify(navigationStack));
        } else {
          navigationStack = JSON.parse(sessionStorage.getItem('navigationStack'));
        }

        // Before navigation starts, detect direction
        document.addEventListener('astro:before-preparation', (event) => {
          // Get target URL from event (it's already a URL object in event.to)
          let targetPath;
          if (event.to) {
            targetPath = event.to.pathname;
          } else {
            return;
          }

          const currentStack = JSON.parse(sessionStorage.getItem('navigationStack') || '[]');

          // Check if we're going back (target path exists earlier in stack)
          const targetIndex = currentStack.indexOf(targetPath);

          if (targetIndex >= 0 && targetIndex < currentStack.length - 1) {
            // Going backward
            navigatingForward = false;
            document.documentElement.setAttribute('data-navigation-direction', 'back');
            // Pop items from stack
            currentStack.splice(targetIndex + 1);
          } else {
            // Going forward
            navigatingForward = true;
            document.documentElement.setAttribute('data-navigation-direction', 'forward');
            // Add to stack if not already there
            if (targetIndex === -1) {
              currentStack.push(targetPath);
            }
          }

          sessionStorage.setItem('navigationStack', JSON.stringify(currentStack));
        });

        // Reset direction after transition completes
        document.addEventListener('astro:after-swap', () => {
          // Keep the direction attribute for the duration of the transition
          setTimeout(() => {
            document.documentElement.removeAttribute('data-navigation-direction');
          }, 300);
        });
      })();
    </script>
  </head>
  <body class="min-h-screen flex flex-col cursor-none">
    <!-- Seline Analytics -->
    <SelineAnalytics />

    <!-- Command Palette -->
    <CommandPalette />

    <!-- Scroll Progress Border -->
    <div id="scroll-progress-border" class="scroll-progress-border" aria-hidden="true">
      <svg class="scroll-progress-svg" preserveAspectRatio="none">
        <rect class="scroll-progress-rect" />
      </svg>
    </div>

    <!-- Custom Cursor -->
    <div id="cursor" class="cursor-wrapper" transition:name="cursor" transition:persist>
      <div class="cursor-dot"></div>
      <div class="cursor-outline"></div>
    </div>

    <Navigation transition:name="nav" transition:persist />

    <main class="flex-1" transition:name="main" transition:animate="fade">
      <slot />
    </main>

    <div transition:name="footer">
      <Footer />
    </div>
    
    <!-- Lenis Smooth Scrolling - Re-initialize on page navigation -->
    <script>
      import Lenis from 'lenis';
      
      let lenis: Lenis | null = null;
      
      function initLenis() {
        // Destroy existing instance
        if (lenis) {
          lenis.destroy();
        }
        
        // Initialize Lenis with Framer-style parameters
        lenis = new Lenis({
          duration: 1.2,
          easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),
          orientation: 'vertical',
          gestureOrientation: 'vertical',
          smoothWheel: true,
          wheelMultiplier: 1,
          touchMultiplier: 2,
          infinite: false,
          autoResize: true,
        });
        
        // RAF loop
        function raf(time: number) {
          if (lenis) {
            lenis.raf(time);
          }
          requestAnimationFrame(raf);
        }
        
        requestAnimationFrame(raf);
        
        // Handle anchor links
        document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
          anchor.addEventListener('click', (e) => {
            e.preventDefault();
            const href = anchor.getAttribute('href');
            if (href && lenis) {
              const target = document.querySelector(href);
              if (target) {
                lenis.scrollTo(target as HTMLElement, {
                  offset: -80,
                  duration: 1.5,
                });
              }
            }
          });
        });
        
        // Expose to window
        (window as any).lenis = lenis;
      }
      
      // Initialize on first load
      initLenis();
      
      // Re-initialize after view transitions
      document.addEventListener('astro:page-load', () => {
        initLenis();
        // Scroll to top on page change
        window.scrollTo(0, 0);
      });
      
      // Handle before swap to clean up
      document.addEventListener('astro:before-swap', () => {
        if (lenis) {
          lenis.destroy();
          lenis = null;
        }
      });
    </script>
    
    <!-- Scroll animations - Re-observe on page navigation -->
    <script>
      function initScrollAnimations() {
        const observerOptions = {
          threshold: 0.1,
          rootMargin: '0px 0px -50px 0px'
        };

        const observer = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              entry.target.classList.add('animated');
            }
          });
        }, observerOptions);

        document.querySelectorAll('.animate-on-scroll').forEach(el => {
          observer.observe(el);
        });
      }
      
      // Initialize on first load and after navigation
      initScrollAnimations();
      document.addEventListener('astro:page-load', initScrollAnimations);
    </script>
    
    <!-- Custom Cursor Logic -->
    <script>
      // Keep cursor state globally so it persists across page transitions
      let cursorInitialized = false;
      let mouseX = -100;
      let mouseY = -100;
      let outlineX = -100;
      let outlineY = -100;
      let animationFrameId: number | null = null;
      
      function initCustomCursor() {
        const cursor = document.getElementById('cursor');
        const cursorDot = cursor?.querySelector('.cursor-dot') as HTMLElement;
        const cursorOutline = cursor?.querySelector('.cursor-outline') as HTMLElement;
        
        if (!cursor || !cursorDot || !cursorOutline) return;
        
        // Clickable elements selector
        const clickableSelector = 'a, button, [role="button"], input[type="submit"], input[type="button"], .clickable';
        const textSelector = 'input[type="text"], input[type="email"], input[type="password"], textarea, [contenteditable="true"]';
        
        // Mouse move handler
        function onMouseMove(e: MouseEvent) {
          mouseX = e.clientX;
          mouseY = e.clientY;
          
          // Immediate update for dot
          cursorDot.style.left = mouseX + 'px';
          cursorDot.style.top = mouseY + 'px';
        }
        
        // Smooth outline following
        function animateOutline() {
          // Lerp for smooth following
          outlineX += (mouseX - outlineX) * 0.15;
          outlineY += (mouseY - outlineY) * 0.15;
          
          cursorOutline.style.left = outlineX + 'px';
          cursorOutline.style.top = outlineY + 'px';
          
          animationFrameId = requestAnimationFrame(animateOutline);
        }
        
        // Mouse enter/leave for clickable elements
        function addHoverListeners() {
          document.querySelectorAll(clickableSelector).forEach((el) => {
            el.addEventListener('mouseenter', () => {
              cursor?.classList.add('hovering');
            });
            el.addEventListener('mouseleave', () => {
              cursor?.classList.remove('hovering');
            });
          });

          // Text input hover
          document.querySelectorAll(textSelector).forEach((el) => {
            el.addEventListener('mouseenter', () => {
              cursor?.classList.add('text');
            });
            el.addEventListener('mouseleave', () => {
              cursor?.classList.remove('text');
            });
          });
        }

        // Hide cursor when leaving window
        function onMouseLeave() {
          cursor?.classList.add('hidden');
        }

        function onMouseEnter() {
          cursor?.classList.remove('hidden');
        }
        
        // Only initialize event listeners once
        if (!cursorInitialized) {
          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseleave', onMouseLeave);
          document.addEventListener('mouseenter', onMouseEnter);
          animateOutline();
          cursorInitialized = true;
        }
        
        // Always re-add hover listeners for new page content
        addHoverListeners();
        
        // Update cursor position immediately if we have a valid position
        if (mouseX > 0 && mouseY > 0) {
          cursorDot.style.left = mouseX + 'px';
          cursorDot.style.top = mouseY + 'px';
          cursorOutline.style.left = outlineX + 'px';
          cursorOutline.style.top = outlineY + 'px';
        }
      }
      
      // Initialize on first load
      initCustomCursor();
      
      // Re-add hover listeners after view transitions (for new page elements)
      document.addEventListener('astro:page-load', initCustomCursor);
    </script>
    
    <!-- Scroll Progress Border Animation -->
    <script>
      function initScrollProgressBorder() {
        const container = document.getElementById('scroll-progress-border');
        const rect = container?.querySelector('.scroll-progress-rect') as SVGRectElement;
        
        if (!container || !rect) return;
        
        // Offset from viewport edge
        const offset = 8;
        
        // Calculate scrollbar width
        function getScrollbarWidth() {
          return window.innerWidth - document.documentElement.clientWidth;
        }
        
        function updateRectDimensions() {
          const scrollbarWidth = getScrollbarWidth();
          // Account for scrollbar on the right side
          const w = window.innerWidth - offset * 2 - scrollbarWidth;
          const h = window.innerHeight - offset * 2;
          
          rect.setAttribute('x', String(offset));
          rect.setAttribute('y', String(offset));
          rect.setAttribute('width', String(w));
          rect.setAttribute('height', String(h));
          rect.setAttribute('rx', '12');
          rect.setAttribute('ry', '12');
          
          // Calculate perimeter
          const perimeter = 2 * (w + h);
          rect.style.strokeDasharray = String(perimeter);
          
          return perimeter;
        }
        
        let perimeter = updateRectDimensions();
        
        function updateScrollProgress() {
          const scrollTop = window.scrollY || document.documentElement.scrollTop;
          const docHeight = document.documentElement.scrollHeight - window.innerHeight;
          const scrollPercent = docHeight > 0 ? scrollTop / docHeight : 0;
          
          // Calculate how much of the perimeter to show
          // Start with none visible (full offset) and end with all visible (0 offset)
          const dashOffset = perimeter * (1 - scrollPercent);
          rect.style.strokeDashoffset = String(dashOffset);
          
          // Hide when at the very top
          if (scrollPercent < 0.01) {
            container?.classList.add('hidden');
          } else {
            container?.classList.remove('hidden');
          }
        }
        
        // Update on scroll
        window.addEventListener('scroll', updateScrollProgress, { passive: true });
        
        // Update dimensions on resize
        window.addEventListener('resize', () => {
          perimeter = updateRectDimensions();
          updateScrollProgress();
        });
        
        // Initial update
        updateScrollProgress();
      }
      
      // Initialize on load
      initScrollProgressBorder();
      
      // Re-initialize after view transitions
      document.addEventListener('astro:page-load', initScrollProgressBorder);
    </script>
    
    <!-- Blog card circular reveal and morph transitions -->
    <script is:inline>
      // Capture click position for circular reveal effect
      document.addEventListener('click', function(e) {
        const blogCard = e.target.closest('[data-blog-card]');
        if (blogCard) {
          // Calculate click position as percentage of viewport
          const x = (e.clientX / window.innerWidth) * 100;
          const y = (e.clientY / window.innerHeight) * 100;

          // Set CSS custom properties for the circular reveal origin
          document.documentElement.style.setProperty('--click-x', x + '%');
          document.documentElement.style.setProperty('--click-y', y + '%');

          // Enable blog transition mode for circular reveal
          document.documentElement.setAttribute('data-blog-transition', 'true');
        } else {
          // Clear blog transition for all other clicks
          document.documentElement.removeAttribute('data-blog-transition');
        }
      });

      // Reset transition mode after navigation completes
      document.addEventListener('astro:after-swap', function() {
        document.documentElement.removeAttribute('data-blog-transition');
      });

      // Also reset before navigation starts
      document.addEventListener('astro:before-preparation', function() {
        // Only keep blog transition if it was just set
        setTimeout(function() {
          const hasBlogTransition = document.documentElement.hasAttribute('data-blog-transition');
          if (!hasBlogTransition) {
            document.documentElement.removeAttribute('data-blog-transition');
          }
        }, 0);
      });
    </script>
    
    <!-- Handle theme persistence and toggle across page transitions -->
    <script is:inline>
      // Helper function to determine if dark mode should be active
      function shouldBeDarkMode() {
        const theme = localStorage.getItem('theme') || 'system';
        const systemDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        return theme === 'dark' || (theme === 'system' && systemDark);
      }
      
      // Apply theme immediately
      // function applyCurrentTheme() { // Removed - currently unused
      //   if (shouldBeDarkMode()) {
      //     document.documentElement.classList.add('dark');
      //   } else {
      //     document.documentElement.classList.remove('dark');
      //   }
      // }
      
      // Full theme application with UI updates
      function applyFullTheme(theme) {
        const root = document.documentElement;
        const systemDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const effectiveTheme = theme === 'system' ? (systemDark ? 'dark' : 'light') : theme;
        
        if (effectiveTheme === 'dark') {
          root.classList.add('dark');
        } else {
          root.classList.remove('dark');
        }
        
        // Update icons
        var sunIcon = document.querySelector('.sun-icon');
        var moonIcon = document.querySelector('.moon-icon');
        var systemIcon = document.querySelector('.system-icon');
        
        if (sunIcon) sunIcon.classList.toggle('hidden', theme !== 'light');
        if (moonIcon) moonIcon.classList.toggle('hidden', theme !== 'dark');
        if (systemIcon) systemIcon.classList.toggle('hidden', theme !== 'system');
        
        // Update checkmarks
        document.querySelectorAll('.theme-option').forEach(function(option) {
          var optionTheme = option.getAttribute('data-theme');
          var checkIcon = option.querySelector('.check-icon');
          if (checkIcon) {
            checkIcon.classList.toggle('hidden', optionTheme !== theme);
          }
        });
      }
      
      function setTheme(theme) {
        localStorage.setItem('theme', theme);
        applyFullTheme(theme);
      }
      
      // Named handler for click events - can be removed/readded
      function handleThemeClick(e) {
        // Handle toggle button click
        var toggleBtn = e.target.closest('#theme-toggle');
        if (toggleBtn) {
          e.preventDefault();
          e.stopPropagation();
          var menu = document.getElementById('theme-menu');
          if (menu) {
            menu.classList.toggle('open');
          }
          return;
        }
        
        // Handle theme option click
        var themeOption = e.target.closest('.theme-option');
        if (themeOption) {
          var theme = themeOption.getAttribute('data-theme');
          if (theme) {
            setTheme(theme);
            var menu = document.getElementById('theme-menu');
            if (menu) menu.classList.remove('open');
          }
          return;
        }
        
        // Close menu when clicking outside
        var menu = document.getElementById('theme-menu');
        if (menu && menu.classList.contains('open')) {
          menu.classList.remove('open');
        }
      }
      
      // Remove old listener if exists, then add fresh one
      if (window.__themeClickHandler) {
        document.removeEventListener('click', window.__themeClickHandler);
      }
      window.__themeClickHandler = handleThemeClick;
      document.addEventListener('click', handleThemeClick);
      
      // Setup other listeners only once
      if (!window.__themeToggleListenersAdded) {
        window.__themeToggleListenersAdded = true;
        
        // Listen for system theme changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', function() {
          var theme = localStorage.getItem('theme') || 'system';
          if (theme === 'system') {
            applyFullTheme('system');
          }
        });
      }
      
      // Apply theme with UI updates on load
      applyFullTheme(localStorage.getItem('theme') || 'system');
      
      // Before swap - carry theme to new document
      document.addEventListener('astro:before-swap', (event) => {
        // Apply current theme state to new document
        if (shouldBeDarkMode()) {
          event.newDocument.documentElement.classList.add('dark');
        } else {
          event.newDocument.documentElement.classList.remove('dark');
        }
        // Remove no-transitions to allow smooth theme
        event.newDocument.documentElement.classList.remove('no-transitions');
      });
      
      // After swap - ensure theme is applied
      document.addEventListener('astro:after-swap', () => {
        applyFullTheme(localStorage.getItem('theme') || 'system');
      });
      
      // After page load - ensure theme is applied
      document.addEventListener('astro:page-load', () => {
        applyFullTheme(localStorage.getItem('theme') || 'system');
      });
    </script>

    <!-- Buy Me a Coffee Widget -->
    <script
      data-name="BMC-Widget"
      data-cfasync="false"
      src="https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js"
      data-id="shawntz"
      data-description="Support me on Buy me a coffee!"
      data-message="ðŸ’› If something I've built has made your work a little easier, your support means a lot â€” it helps me keep creating and sharing."
      data-color="#12574A"
      data-position="Right"
      data-x_margin="18"
      data-y_margin="18"
    ></script>

    <!-- Command Palette Global Keyboard Shortcut -->
    <script is:inline>
      // Global Cmd+K / Ctrl+K listener
      document.addEventListener('keydown', function(e) {
        // Check for Cmd+K (Mac) or Ctrl+K (Windows/Linux)
        if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
          e.preventDefault();
          // Dispatch custom event to open command palette
          document.dispatchEvent(new CustomEvent('openCommandPalette'));
        }
      });
    </script>
  </body>
</html>
